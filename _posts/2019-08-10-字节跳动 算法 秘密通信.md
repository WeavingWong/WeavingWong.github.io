

```python

小明和小红采用密码加密通信，每次通信有固定的明文长度n和加密次数k。
比如：密码二进制明文是1001010，加密次数是4，则每次将密文右移1位与明文做异或操作，总共位移3次（k=4, 所以k - 1 = 3）
输入：
7 4 // n k
1110100110 //密文
输出：
1001010 //明文

解释：
1001010---
-1001010--
--1001010-
---1001010
加密次数为4，故对于明文右移4-1=3轮，每轮与当前密文进行一次异或，故1001010对应密文为1110100110


首先密文和明文第1位是一样的，看一下上方样例里的解释就懂了。
然后考虑第2到k-1位，可以发现这一段的每一位都是由前一位密文的异或结果再与当前位明文异或得到的。
接下来考虑第k到n-1位，观察规律可以发现这一段的每一位都是由前一位密文与第i-k位明文异或得到的结果再与当前位明文异或得到的。
```


```python
#!/bin/python
# -*- coding: utf8 -*-
import sys
import os
import re


def xor(a, b):
    return ('0' if (a == b) else '1')


def GetResult(N, K, bin_str):
    result = [0] * N
    result[0] = bin_str[0]
    for i in range(1, K, 1):
        result[i] = xor(bin_str[i], bin_str[i - 1])
    for i in range(K, N, 1):
        result[i] = xor(xor(bin_str[i], bin_str[i - 1]), result[i - K])
    return result


N, K = map(int, input().split())
bin_str = str(input())
res = GetResult(N, K, bin_str)

print(''.join(res))
```

    7 4
    1110100110
    1001010
    


```python
// java 版本

package b;
 
import java.util.Scanner;
 
public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int k = scanner.nextInt();
        String secret = scanner.next();
        char[] result = new char[n];
        result[0] = secret.charAt(0);
        for (int i = 1; i < k; i++) {
            result[i] = xor(secret.charAt(i), secret.charAt(i - 1));
        }
        for (int i = k; i < n; i++) {
            result[i] = xor(xor(secret.charAt(i), secret.charAt(i - 1)), result[i - k]);
        }
 
        System.out.println(new String(result));
    }
 
    private static char xor(char a, char b) {
        return a == b ? '0' : '1';
    }
}
```


```python

```
